<!-- TODO: hier "Home Page" implementieren  ("/") -->
<!-- s. Boilerplate code unten eventuell löschen -->


<div class="index-page-content">
  {% for product in collections.main-products.products %}
  <div class="index-page-product">
    <a href="{{ product.url }}">
      <div class="index-page-product__content">
        <h1> {{ product.title | upcase }} </h1>
        <div class="index-page-product__description">
          {{ product.description }}
        </div>
        <div class="index-page-product__cta">
          <div> Shop now </div>
          <div class="arrow-image-container">
            <img src="{{ 'arrow.svg' | asset_url }}" alt="arrow-image">
          </div>
        </div>
      </div>
      {% assign images = product.media | where: "media_type", "image" %}
      {% assign mainImageSrc = images[0].image.src | product_img_url: '1000x' %}
      <div class="index-page-product-image-background" data-lazy-src="{{ mainImageSrc }}">  </div>
    </a>
  </div>
    
{% endfor %}

</div>







<style>
  .brand-name {
    position: absolute;
    font-size: 5rem;
    top: 25vh;
    transform: translateX(calc(50vw - 50%));    /* MARK: best practice um ein position: absolute element zu centrieren? */
    /* transform-origin: 50% 100%                  https://davidwalsh.name/parallax-scroll */
  }
</style>



<!-- product scroll script -->
<script>
  const productSections = document.querySelectorAll(".index-page-product")
  const productContents = document.querySelectorAll(".index-page-product__content")

  const productSectionOptions = {
    // root: null   --> viewport (default)
    root: null,
    threshold: 0,
    rootMargin: "0px 0px 0px 0px"    // zb "-150px" -> s. wann text eingeblendet werden soll
  }


  const productSectionObserver = new IntersectionObserver(
    (entries, observer) => {
      entries.forEach((entry) => {
        // target ==  single productSection
        // target.children[0] == a tag
        // target.children[0].children[0] == content div
        // target.children[0].children[1] ==  div

        const product = entry.target
        const bgImgContainer = entry.target.children[0].children[1]   // class="index-page-product-image-background

        // lazyloading der images: https://www.youtube.com/watch?v=aUjBvuUdkhgr
        if (entry.isIntersecting) {
          console.log("is Interseting");
          preloadImage(bgImgContainer) 
          product.children[0].children[0].classList.add("product-content-show")
          // observer.unobserve(entry.target) -> wann aufrufen?!
        } 
        else if (!entry.isIntersecting) {
          // TODO: Wenn product.title mehr als eine zeile einnimmt, dann funktioniert der display fix nicht mehr wie gewollt
          product.children[0].children[0].classList.remove("product-content-show")
          // observer.unobserve(entry.target) -> wann aufrufen?!
        }
      })
    },productSectionOptions)
  


  function preloadImage(imgDiv) {
    const bgImgPath = imgDiv.dataset.lazySrc
    if (!bgImgPath) {
      // TODO: placeholder product image, mit der message, dass das original nicht laden konnte
      return 
    }
    imgDiv.style.backgroundImage = `url(${bgImgPath})`
  }


  productSections.forEach(
    (product) => {
      productSectionObserver.observe(product)
    }
  )

  



</script>




<!-- Header Scroll script -->
<script>
  // TODO: irgendwie festellen, wann target.y value mit dem vom header kolidiert bzw wann taget wieder den selben y wert hat wie ohne position absolute

  // Mit jQuery veruschen s.
  // https://stackoverflow.com/questions/15123262/positionfixed-navigation-stop-at-end-of-specific-div-parallax-scrolling-jav
  const target = document.querySelector(".brand-name")
  const header = document.querySelector("header")
  // const productSections = document.querySelectorAll(".index-page-product")

  const headerRect = header.getBoundingClientRect()
  const initialTargetRect = target.getBoundingClientRect()

  // console.log("headerRect", headerRect);  

  var targetIsLocked = false

  window.addEventListener("scroll", function(e) { 

    const targetRect = target.getBoundingClientRect()

    const offset = window.pageYOffset
    const scrollRate = offset * - .7


    // TODO scale rate nicht durch offset teilen sondern durch einen Iterator (außerhalb vom scroll eventhandler definieren -> und dann extra functino schreiben die diesen multiplikator bei unterschiedlichen offsets / window heights verändert)
    const scaleRate = 130 / offset

    // TODO: geht so leider nicht da wenn kleinerer (verticaler screen) -> andere offset ratio -> stattdessen ähnlich wie unten versuchen
    // veruschen mit vh werten zu arbeiten -> auch in scrollRate und scaleRate!
    // console.log("offset: ", offset);
    // console.log("initialTargetRect: ", initialTargetRect);
    // console.log("headerRect: ", headerRect);

    // (offset < 506)
      if (targetRect.y >= headerRect.height/2 - (targetRect.height/2)) {
        target.style.transform = `translate3d(calc(50vw - 50%), ${scrollRate}px,0)`
          // to fix the scale bug!
          if (offset < 450) {
            target.style.transform = `translate3d(calc(50vw - 50%),${scrollRate}px,0))` //  transformX(calc(50vw - 50%))
        }
        if (offset > 144 ) {
          target.style.transform = `translate3d(calc(50vw - 50%),${scrollRate}px,0) scale(${scaleRate})` //  transformX(calc(50vw - 50%))
        }
      }





      if (offset < initialTargetRect.y + initialTargetRect.height) {
        target.style.transform = `translate3d(calc(50vw - 50%), ${scrollRate}px,0)`
          // to fix the scale bug!
          if (offset < 450) {
            target.style.transform = `translate3d(calc(50vw - 50%),${scrollRate}px,0))` //  transformX(calc(50vw - 50%))
        }
        if (offset > 144 ) {
          target.style.transform = `translate3d(calc(50vw - 50%),${scrollRate}px,0) scale(${scaleRate})` //  transformX(calc(50vw - 50%))
        }

      }
  })



  // if (targetRect.y >= headerRect.height/2 - (targetRect.height/2)) {
  //       target.style.transform = `translate3d(calc(50vw - 50%), ${scrollRate}px,0)`

  //         // to fix the scale bug!
  //         if (offset < 450) {
  //           target.style.transform = `translate3d(calc(50vw - 50%),${scrollRate}px,0))` //  transformX(calc(50vw - 50%))
  //       }

  //       if (offset > 144 ) {
  //         target.style.transform = `translate3d(calc(50vw - 50%),${scrollRate}px,0) scale(${scaleRate})` //  transformX(calc(50vw - 50%))
  //       }
  //     // TODO: if targRect.y <= headerRect.height/2 - (targetRect.height/2) { umgekeherte scroll/scale weerte bis initial.y erraiech  } 
  //     // ab offset 506 ist targetRect.y >= headerRect.height/2 - (targetRect.height/2) == false d.h .brand-name in seiner ursprünglichen position


  //     // if offset == 250 bzw initialTargetRect && initialTargetRect.y != target.y -> dann wieder runter scrollen
  //     }


</script>












<!-- {% for product in collections.main.products limit:4 %}

  <div>
    <a href="{{ product.url | within: collection }}"> {{ product.title }}</a>
    {{ product.price | money }}
    {% unless product.available %}<br><strong>sold out</strong>{% endunless %}
    <a href="{{ product.url | within: collection }}">
      <img src="{{ product.featured_image.src | img_url: 'large' }}" alt="{{ product.featured_image.alt | escape }}">
    </a>
  </div>
{% endfor %} -->

